{"ts":1352613395189,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * Module dependencies.\n * @ignore\n */\nvar QueryCommand = require('./commands/query_command').QueryCommand,\n  DbCommand = require('./commands/db_command').DbCommand,\n  MongoReply = require('./responses/mongo_reply').MongoReply,\n  Admin = require('./admin').Admin,\n  Collection = require('./collection').Collection,\n  Server = require('./connection/server').Server,\n  ReplSet = require('./connection/repl_set').ReplSet,\n  ReadPreference = require('./connection/read_preference').ReadPreference,\n  Mongos = require('./connection/mongos').Mongos,\n  Cursor = require('./cursor').Cursor,\n  EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits,\n  crypto = require('crypto');\n\n/**\n * Internal class for callback storage\n * @ignore\n */\nvar CallbackStore = function() {\n  // Make class an event emitter\n  EventEmitter.call(this);\n  // Add a info about call variable\n  this._notReplied = {};\n}\n\n/**\n * @ignore\n */\ninherits(CallbackStore, EventEmitter);\n\n/**\n * Create a new Db instance.\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, execute insert with a getLastError command returning the result of the insert command.\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *  - **native_parser** {Boolean, default:false}, use c++ bson parser.\n *  - **forceServerObjectId** {Boolean, default:false}, force server to create _id fields instead of client.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions.\n *  - **raw** {Boolean, default:false}, peform operations using raw bson buffers.\n *  - **recordQueryStats** {Boolean, default:false}, record query statistics during execution.\n *  - **reaper** {Boolean, default:false}, enables the reaper, timing out calls that never return.\n *  - **reaperInterval** {Number, default:10000}, number of miliseconds between reaper wakups.\n *  - **reaperTimeout** {Number, default:30000}, the amount of time before a callback times out.\n *  - **retryMiliSeconds** {Number, default:5000}, number of miliseconds between retries.\n *  - **numberOfRetries** {Number, default:5}, number of retries off connection.\n *\n * @class Represents a Collection\n * @param {String} databaseName name of the database.\n * @param {Object} serverConfig server config object.\n * @param {Object} [options] additional options for the collection.\n */\nfunction Db(databaseName, serverConfig, options) {\n\n  if(!(this instanceof Db)) return new Db(databaseName, serverConfig, options);\n\n  EventEmitter.call(this);\n  this.databaseName = databaseName;\n  this.serverConfig = serverConfig;\n  this.options = options == null ? {} : options;\n  // State to check against if the user force closed db\n  this._applicationClosed = false;\n  // Fetch the override flag if any\n  var overrideUsedFlag = this.options['override_used_flag'] == null ? false : this.options['override_used_flag'];\n  // Verify that nobody is using this config\n  if(!overrideUsedFlag && typeof this.serverConfig == 'object' && this.serverConfig._isUsed()) {\n    throw new Error(\"A Server or ReplSet instance cannot be shared across multiple Db instances\");\n  } else if(!overrideUsedFlag && typeof this.serverConfig == 'object'){\n    // Set being used\n    this.serverConfig._used = true;\n  }\n\n  // Ensure we have a valid db name\n  validateDatabaseName(databaseName);\n\n  // Contains all the connections for the db\n  try {\n    this.native_parser = this.options.native_parser;\n    // The bson lib\n    var bsonLib = this.bsonLib = this.options.native_parser ? require('bson').BSONNative : new require('bson').BSONPure;\n    // Fetch the serializer object\n    var BSON = bsonLib.BSON;\n    // Create a new instance\n    this.bson = new BSON([bsonLib.Long, bsonLib.ObjectID, bsonLib.Binary, bsonLib.Code, bsonLib.DBRef, bsonLib.Symbol, bsonLib.Double, bsonLib.Timestamp, bsonLib.MaxKey, bsonLib.MinKey]);\n    // Backward compatibility to access types\n    this.bson_deserializer = bsonLib;\n    this.bson_serializer = bsonLib;\n  } catch (err) {\n    // If we tried to instantiate the native driver\n    var msg = \"Native bson parser not compiled, please compile \"\n            + \"or avoid using native_parser=true\";\n    throw Error(msg);\n  }\n\n  // Internal state of the server\n  this._state = 'disconnected';\n\n  this.pkFactory = this.options.pk == null ? bsonLib.ObjectID : this.options.pk;\n  this.forceServerObjectId = this.options.forceServerObjectId != null ? this.options.forceServerObjectId : false;\n\n  // Added safe\n  this.safe = this.options.safe == null ? false : this.options.safe;  \n\n  // If we have not specified a \"safe mode\" we just print a warning to the console\n  if(this.options.safe == null) {\n    console.log(\"========================================================================================\");\n    console.log(\"=  Please ensure that you set the default safe variable to one of the                  =\");\n    console.log(\"=   allowed values of [true | false | {j:true} | {w:n, wtimeout:n} | {fsync:true}]     =\");\n    console.log(\"=   the default value is false which means the driver receives does not                =\");\n    console.log(\"=   return the information of the success/error of the insert/update/remove            =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=   ex: new Db(new Server('localhost', 27017), {safe:false})                           =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=   http://www.mongodb.org/display/DOCS/getLastError+Command                           =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=  The default of false will change to true in the near future                         =\");\n    console.log(\"=                                                                                      =\");\n    console.log(\"=  This message will disappear when the default safe is set on the driver Db           =\");\n    console.log(\"========================================================================================\");\n  }\n\n  // Internal states variables\n  this.notReplied ={};\n  this.isInitializing = true;\n  this.auths = [];\n  this.openCalled = false;\n\n  // Command queue, keeps a list of incoming commands that need to be executed once the connection is up\n  this.commands = [];\n\n  // Contains all the callbacks\n  this._callBackStore = new CallbackStore();\n\n  // Set up logger\n  this.logger = this.options.logger != null\n    && (typeof this.options.logger.debug == 'function')\n    && (typeof this.options.logger.error == 'function')\n    && (typeof this.options.logger.log == 'function')\n      ? this.options.logger : {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};\n  // Allow slaveOk\n  this.slaveOk = this.options[\"slave_ok\"] == null ? false : this.options[\"slave_ok\"];\n\n  var self = this;\n  // Associate the logger with the server config\n  this.serverConfig.logger = this.logger;\n  this.tag = new Date().getTime();\n  // Just keeps list of events we allow\n  this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[]};\n\n  // Controls serialization options\n  this.serializeFunctions = this.options.serializeFunctions != null ? this.options.serializeFunctions : false;\n\n  // Raw mode\n  this.raw = this.options.raw != null ? this.options.raw : false;\n\n  // Record query stats\n  this.recordQueryStats = this.options.recordQueryStats != null ? this.options.recordQueryStats : false;\n\n  // If we have server stats let's make sure the driver objects have it enabled\n  if(this.recordQueryStats == true) {\n    this.serverConfig.enableRecordQueryStats(true);\n  }\n\n  // Reaper enable setting\n  this.reaperEnabled = this.options.reaper != null ? this.options.reaper : false;\n  this._lastReaperTimestamp = new Date().getTime();\n\n  // Retry information\n  this.retryMiliSeconds = this.options.retryMiliSeconds != null ? this.options.retryMiliSeconds : 1000;\n  this.numberOfRetries = this.options.numberOfRetries != null ? this.options.numberOfRetries : 60;\n\n  // Reaper information\n  this.reaperInterval = this.options.reaperInterval != null ? this.options.reaperInterval : 10000;\n  this.reaperTimeout = this.options.reaperTimeout != null ? this.options.reaperTimeout : 30000;\n\n  // Set default read preference if any\n  this.readPreference = this.options.readPreference;\n};\n\n/**\n * The reaper cleans up any callbacks that have not returned inside the space set by\n * the parameter reaperTimeout, it will only attempt to reap if the time since last reap\n * is bigger or equal to the reaperInterval value\n * @ignore\n */\nvar reaper = function(dbInstance, reaperInterval, reaperTimeout) {\n  // Get current time, compare to reaper interval\n  var currentTime = new Date().getTime();\n  // Now calculate current time difference to check if it's time to reap\n  if((currentTime - dbInstance._lastReaperTimestamp) >= reaperInterval) {\n    // Save current timestamp for next reaper iteration\n    dbInstance._lastReaperTimestamp = currentTime;\n    // Get all non-replied to messages\n    var keys = Object.keys(dbInstance._callBackStore._notReplied);\n    // Iterate over all callbacks\n    for(var i = 0; i < keys.length; i++) {\n      // Fetch the current key\n      var key = keys[i];\n      // Get info element\n      var info = dbInstance._callBackStore._notReplied[key];\n      // If it's timed out let's remove the callback and return an error\n      if((currentTime - info.start) > reaperTimeout) {\n        // Cleanup\n        delete dbInstance._callBackStore._notReplied[key];\n        // Perform callback in next Tick\n        process.nextTick(function() {\n          if(dbInstance._callBackStore \n            && dbInstance._callBackStore.listeners(key).length > 0\n            && typeof dbInstance._callBackStore.listeners(key)[0] == 'function') {\n            dbInstance._callBackStore.emit(key, new Error(\"operation timed out\"), null);            \n          } else if(dbInstance._callBackStore \n            && dbInstance._callBackStore.listeners(key).length > 0) {\n            console.log(\"================================================= _callBackStore listener not a function\");\n            console.dir(dbInstance._callBackStore.listeners(key));\n          }\n        });\n      }\n    }\n    // Return reaping was done\n    return true;\n  } else {\n    // No reaping done\n    return false;\n  }\n}\n\n/**\n * @ignore\n */\nfunction validateDatabaseName(databaseName) {\n  if(typeof databaseName !== 'string') throw new Error(\"database name must be a string\");\n  if(databaseName.length === 0) throw new Error(\"database name cannot be the empty string\");\n\n  var invalidChars = [\" \", \".\", \"$\", \"/\", \"\\\\\"];\n  for(var i = 0; i < invalidChars.length; i++) {\n    if(databaseName.indexOf(invalidChars[i]) != -1) throw new Error(\"database names cannot contain the character '\" + invalidChars[i] + \"'\");\n  }\n}\n\n/**\n * @ignore\n */\ninherits(Db, EventEmitter);\n\n/**\n * Initialize the database connection.\n *\n * @param {Function} callback returns index information.\n * @return {null}\n * @api public\n */\nDb.prototype.open = function(callback) {\n  var self = this;\n\n  // Check that the user has not called this twice\n  if(this.openCalled) {\n    // Close db\n    this.close();\n    // Throw error\n    throw new Error(\"db object already connecting, open cannot be called multiple times\");\n  }\n\n  // If we have a specified read preference\n  if(this.readPreference != null) this.serverConfig.setReadPreference(this.readPreference);\n\n  // Set that db has been opened\n  this.openCalled = true;\n  // Set the status of the server\n  self._state = 'connecting';\n  // Set up connections\n  if(self.serverConfig instanceof Server || self.serverConfig instanceof ReplSet || self.serverConfig instanceof Mongos) {\n    self.serverConfig.connect(self, {firstCall: true}, function(err, result) {\n      if(err != null) {\n        // Set that db has been closed\n        self.openCalled = false;\n        // Return error from connection\n        return callback(err, null);\n      }\n      // Set the status of the server\n      self._state = 'connected';\n      // Callback\n      return callback(null, self);\n    });\n  } else {\n    return callback(Error(\"Server parameter must be of type Server, ReplSet or Mongos\"), null);\n  }\n};\n\n/**\n * Create a new Db instance sharing the current socket connections.\n *\n * @param {String} dbName the name of the database we want to use.\n * @return {Db} a db instance using the new database.\n * @api public\n */\nDb.prototype.db = function(dbName) {\n  // Copy the options and add out internal override of the not shared flag\n  var options = {};\n  for(var key in this.options) {\n    options[key] = this.options[key];\n  }\n  // Add override flag\n  options['override_used_flag'] = true;\n  // Create a new db instance\n  var newDbInstance = new Db(dbName, this.serverConfig, options);\n  //copy over any auths, we may need them for reconnecting\n  if (this.serverConfig.db) {\n    newDbInstance.auths = this.serverConfig.db.auths;\n  }\n  // Add the instance to the list of approved db instances\n  var allServerInstances = this.serverConfig.allServerInstances();\n  // Add ourselves to all server callback instances\n  for(var i = 0; i < allServerInstances.length; i++) {\n    var server = allServerInstances[i];\n    server.dbInstances.push(newDbInstance);\n  }\n  // Return new db object\n  return newDbInstance;\n}\n\n/**\n * Close the current db connection, including all the child db instances. Emits close event if no callback is provided.\n *\n * @param {Boolean} [forceClose] connection can never be reused.\n * @param {Function} [callback] returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.close = function(forceClose, callback) {\n  var self = this;\n  // Ensure we force close all connections\n  this._applicationClosed = false;\n\n  if(typeof forceClose == 'function') {\n    callback = forceClose;\n  } else if(typeof forceClose == 'boolean') {\n    this._applicationClosed = forceClose;\n  }\n\n  // Remove all listeners and close the connection\n  this.serverConfig.close(function(err, result) {\n    // Emit the close event\n    if(typeof callback !== 'function') self.emit(\"close\");\n\n    // Emit close event across all db instances sharing the sockets\n    var allServerInstances = self.serverConfig.allServerInstances();\n    // Fetch the first server instance\n    if(Array.isArray(allServerInstances) && allServerInstances.length > 0) {\n      var server = allServerInstances[0];\n      // For all db instances signal all db instances\n      if(Array.isArray(server.dbInstances) && server.dbInstances.length > 1) {\n    \t  for(var i = 0; i < server.dbInstances.length; i++) {\n          var dbInstance = server.dbInstances[i];\n          // Check if it's our current db instance and skip if it is\n          if(dbInstance.databaseName !== self.databaseName && dbInstance.tag !== self.tag) {\n            server.dbInstances[i].emit(\"close\");\n          }\n        }\n      }\n    }\n\n    // Remove all listeners\n    self.removeAllEventListeners();\n    // You can reuse the db as everything is shut down\n    self.openCalled = false;\n    // If we have a callback call it\n    if(callback) callback(err, result);\n  });\n};\n\n/**\n * Access the Admin database\n *\n * @param {Function} [callback] returns the results.\n * @return {Admin} the admin db object.\n * @api public\n */\nDb.prototype.admin = function(callback) {\n  if(callback == null) return new Admin(this);\n  callback(null, new Admin(this));\n};\n\n/**\n * Returns a cursor to all the collection information.\n *\n * @param {String} [collectionName] the collection name we wish to retrieve the information from.\n * @param {Function} callback returns option results.\n * @return {null}\n * @api public\n */\nDb.prototype.collectionsInfo = function(collectionName, callback) {\n  if(callback == null && typeof collectionName == 'function') { callback = collectionName; collectionName = null; }\n  // Create selector\n  var selector = {};\n  // If we are limiting the access to a specific collection name\n  if(collectionName != null) selector.name = this.databaseName + \".\" + collectionName;\n\n  // Return Cursor\n  // callback for backward compatibility\n  if(callback) {\n    callback(null, new Cursor(this, new Collection(this, DbCommand.SYSTEM_NAMESPACE_COLLECTION), selector));\n  } else {\n    return new Cursor(this, new Collection(this, DbCommand.SYSTEM_NAMESPACE_COLLECTION), selector);\n  }\n};\n\n/**\n * Get the list of all collection names for the specified db\n *\n * Options\n *  - **namesOnly** {String, default:false}, Return only the full collection namespace.\n *\n * @param {String} [collectionName] the collection name we wish to filter by.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback returns option results.\n * @return {null}\n * @api public\n */\nDb.prototype.collectionNames = function(collectionName, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  collectionName = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n\n  // Ensure no breaking behavior\n  if(collectionName != null && typeof collectionName == 'object') {\n    options = collectionName;\n    collectionName = null;\n  }\n\n  // Let's make our own callback to reuse the existing collections info method\n  self.collectionsInfo(collectionName, function(err, cursor) {\n    if(err != null) return callback(err, null);\n\n    cursor.toArray(function(err, documents) {\n      if(err != null) return callback(err, null);\n\n      // List of result documents that have been filtered\n      var filtered_documents = documents.filter(function(document) {\n        return !(document.name.indexOf(self.databaseName) == -1 || document.name.indexOf('$') != -1);\n      });\n\n      // If we are returning only the names\n      if(options.namesOnly) {\n        filtered_documents = filtered_documents.map(function(document) { return document.name });\n      }\n\n      // Return filtered items\n      callback(null, filtered_documents);\n    });\n  });\n};\n\n/**\n * Fetch a specific collection (containing the actual collection information)\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n *  - **raw** {Boolean, default:false}, perform all operations using raw bson objects.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *\n * @param {String} collectionName the collection name we wish to access.\n * @param {Object} [options] returns option results.\n * @param {Function} [callback] returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.collection = function(collectionName, options, callback) {\n  var self = this;\n  if(typeof options === \"function\") { callback = options; options = {}; }\n  // Execute safe\n  if(options && options.safe) {\n    self.collectionNames(collectionName, function(err, collections) {\n      if(err != null) return callback(err, null);\n\n      if(collections.length == 0) {\n        return callback(new Error(\"Collection \" + collectionName + \" does not exist. Currently in safe mode.\"), null);\n      } else {\n        try {\n          var collection = new Collection(self, collectionName, self.pkFactory, options);\n        } catch(err) {\n          return callback(err, null);\n        }\n        return callback(null, collection);\n      }\n    });\n  } else {\n    try {\n      var collection = new Collection(self, collectionName, self.pkFactory, options);\n    } catch(err) {\n      if(callback == null) {\n        throw err;\n      } else {\n        return callback(err, null);\n      }\n    }\n\n    // If we have no callback return collection object\n    return callback == null ? collection : callback(null, collection);\n  }\n};\n\n/**\n * Fetch all collections for the current db.\n *\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.collections = function(callback) {\n  var self = this;\n  // Let's get the collection names\n  self.collectionNames(function(err, documents) {\n    if(err != null) return callback(err, null);\n    var collections = [];\n    documents.forEach(function(document) {\n      collections.push(new Collection(self, document.name.replace(self.databaseName + \".\", ''), self.pkFactory));\n    });\n    // Return the collection objects\n    callback(null, collections);\n  });\n};\n\n/**\n * Evaluate javascript on the server\n *\n * Options\n *  - **nolock** {Boolean, default:false}, Tell MongoDB not to block on the evaulation of the javascript.\n *\n * @param {Code} code javascript to execute on server.\n * @param {Object|Array} [parameters] the parameters for the call.\n * @param {Object} [options] the options\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.eval = function(code, parameters, options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  parameters = args.length ? args.shift() : parameters;\n  options = args.length ? args.shift() : {};\n\n  var finalCode = code;\n  var finalParameters = [];\n  // If not a code object translate to one\n  if(!(finalCode instanceof this.bsonLib.Code)) {\n    finalCode = new this.bsonLib.Code(finalCode);\n  }\n\n  // Ensure the parameters are correct\n  if(parameters != null && parameters.constructor != Array && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if(parameters != null && parameters.constructor == Array && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  }\n\n  // Create execution selector\n  var selector = {'$eval':finalCode, 'args':finalParameters};\n  // Check if the nolock parameter is passed in\n  if(options['nolock']) {\n    selector['nolock'] = options['nolock'];\n  }\n\n  // Set primary read preference\n  options.readPreference = ReadPreference.PRIMARY;\n\n  // Execute the eval\n  this.collection(DbCommand.SYSTEM_COMMAND_COLLECTION).findOne(selector, options, function(err, result) {\n    if(err) return callback(err);\n\n    if(result && result.ok == 1) {\n      callback(null, result.retval);\n    } else if(result) {\n      callback(new Error(\"eval failed: \" + result.errmsg), null); return;\n    } else {\n      callback(err, result);\n    }\n  });\n};\n\n/**\n * Dereference a dbref, against a db\n *\n * @param {DBRef} dbRef db reference object we wish to resolve.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.dereference = function(dbRef, callback) {\n  var db = this;\n  // If we have a db reference then let's get the db first\n  if(dbRef.db != null) db = this.db(dbRef.db);\n  // Fetch the collection and find the reference\n  var collection = db.collection(dbRef.namespace);\n  collection.findOne({'_id':dbRef.oid}, function(err, result) {\n    callback(err, result);\n  });\n};\n\n/**\n * Logout user from server, fire off on all connections and remove all auth info\n *\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.logout = function(options, callback) {\n  var self = this;\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Number of connections we need to logout from\n  var numberOfConnections = this.serverConfig.allRawConnections().length;\n\n  // Let's generate the logout command object\n  var logoutCommand = DbCommand.logoutCommand(self, {logout:1}, options);\n  self._executeQueryCommand(logoutCommand, {onAll:true}, function(err, result) {\n    // Count down\n    numberOfConnections = numberOfConnections - 1;\n    // Work around the case where the number of connections are 0\n    if(numberOfConnections <= 0 && typeof callback == 'function') {\n      var internalCallback = callback;\n      callback = null;\n      // Reset auth\n      self.auths = [];\n      // Handle any errors\n      if(err == null && result.documents[0].ok == 1) {\n        internalCallback(null, true);\n      } else {\n        err != null ? internalCallback(err, false) : internalCallback(new Error(result.documents[0].errmsg), false);\n      }\n    }\n  });\n}\n\n/**\n * Authenticate a user against the server.\n *\n * Options\n *  - **authdb** {String}, The database that the credentials are for,\n *    different from the name of the current DB, for example admin\n * @param {String} username username.\n * @param {String} password password.\n * @param {Object} [options] the options\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.authenticate = function(username, password, options, callback) {\n  var self = this;\n\n  if (typeof callback === 'undefined') {\n    callback = options;\n    options = {};\n  }\n  // the default db to authenticate against is 'this'\n  // if authententicate is called from a retry context, it may be another one, like admin\n  var authdb = options.authdb ? options.authdb : self.databaseName;\n\n  // Push the new auth if we have no previous record\n  // Get the amount of connections in the pool to ensure we have authenticated all comments\n  var numberOfConnections = this.serverConfig.allRawConnections().length;\n  var errorObject = null;\n\n  // Execute all four\n  this._executeQueryCommand(DbCommand.createGetNonceCommand(self), {onAll:true}, function(err, result, connection) {\n    // Execute on all the connections\n    if(err == null) {\n      // Nonce used to make authentication request with md5 hash\n      var nonce = result.documents[0].nonce;\n      // Execute command\n      self._executeQueryCommand(DbCommand.createAuthenticationCommand(self, username, password, nonce, authdb), {connection:connection}, function(err, result) {\n        // Count down\n        numberOfConnections = numberOfConnections - 1;\n        // Ensure we save any error\n        if(err) {\n          errorObject = err;\n        } else if(result.documents[0].err != null || result.documents[0].errmsg != null){\n          errorObject = self.wrap(result.documents[0]);\n        }\n\n        // Work around the case where the number of connections are 0\n        if(numberOfConnections <= 0 && typeof callback == 'function') {\n          var internalCallback = callback;\n          callback = null;\n\n          if(errorObject == null && result.documents[0].ok == 1) {\n            // We authenticated correctly save the credentials\n            self.auths = [{'username':username, 'password':password, 'authdb': authdb}];\n            // Return callback\n            internalCallback(errorObject, true);\n          } else {\n            internalCallback(errorObject, false);\n          }\n        }\n      });\n    }\n  });\n};\n\n/**\n * Add a user to the database.\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} username username.\n * @param {String} password password.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.addUser = function(username, password, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? true : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? true : safe;\n\n  // Use node md5 generator\n  var md5 = crypto.createHash('md5');\n  // Generate keys used for authentication\n  md5.update(username + \":mongo:\" + password);\n  var userPassword = md5.digest('hex');\n  // Fetch a user collection\n  var collection = this.collection(DbCommand.SYSTEM_USER_COLLECTION);\n  // Check if we are inserting the first user\n  collection.count({}, function(err, count) {\n    // We got an error (f.ex not authorized)\n    if(err != null) return callback(err, null);\n    // Check if the user exists and update i\n    collection.find({user: username}, {dbName: options['dbName']}).toArray(function(err, documents) {\n      // We got an error (f.ex not authorized)\n      if(err != null) return callback(err, null);\n      // We have a user, let's update the password or upsert if not\n      collection.update({user: username},{$set: {user: username, pwd: userPassword}}, {safe:safe, dbName: options['dbName'], upsert:true}, function(err, results) {\n        if(count == 0 && err) {\n          callback(null, [{user:username, pwd:userPassword}]);\n        } else if(err) {\n          callback(err, null)\n        } else {\n          callback(null, [{user:username, pwd:userPassword}]);\n        }\n      });\n    });\n  });\n};\n\n/**\n * Remove a user from a database\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *\n * @param {String} username username.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.removeUser = function(username, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? true : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? true : safe;\n\n  // Fetch a user collection\n  var collection = this.collection(DbCommand.SYSTEM_USER_COLLECTION);\n  collection.findOne({user: username}, {dbName: options['dbName']}, function(err, user) {\n    if(user != null) {\n      collection.remove({user: username}, {safe:safe, dbName: options['dbName']}, function(err, result) {\n        callback(err, true);\n      });\n    } else {\n      callback(err, false);\n    }\n  });\n};\n\n/**\n * Creates a collection on a server pre-allocating space, need to create f.ex capped collections.\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.\n *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.\n *  - **raw** {Boolean, default:false}, perform all operations using raw bson objects.\n *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.\n *  - **capped** {Boolean, default:false}, create a capped collection.\n *  - **size** {Number}, the size of the capped collection in bytes.\n *  - **max** {Number}, the maximum number of documents in the capped collection.\n *  - **autoIndexId** {Boolean, default:false}, create an index on the _id field of the document, not created automatically on capped collections.\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *\n * @param {String} collectionName the collection name we wish to access.\n * @param {Object} [options] returns option results.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.createCollection = function(collectionName, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : null;\n  var self = this;\n\n  // Figure out the safe mode settings\n  var safe = self.safe != null && self.safe == false ? true : self.safe;\n  // Override with options passed in if applicable\n  safe = options != null && options['safe'] != null ? options['safe'] : safe;\n  // Ensure it's at least set to safe\n  safe = safe == null ? true : safe;\n\n  // Check if we have the name\n  this.collectionNames(collectionName, function(err, collections) {\n    if(err != null) return callback(err, null);\n\n    var found = false;\n    collections.forEach(function(collection) {\n      if(collection.name == self.databaseName + \".\" + collectionName) found = true;\n    });\n\n    // If the collection exists either throw an exception (if db in safe mode) or return the existing collection\n    if(found && ((options && options.safe))) {\n      return callback(new Error(\"Collection \" + collectionName + \" already exists. Currently in safe mode.\"), null);\n    } else if(found){\n      try {\n        var collection = new Collection(self, collectionName, self.pkFactory, options);\n      } catch(err) {\n        return callback(err, null);\n      }\n      return callback(null, collection);\n    }\n\n    // Create a new collection and return it\n    self._executeQueryCommand(DbCommand.createCreateCollectionCommand(self, collectionName, options), {read:false, safe:safe}, function(err, result) {\n      var document = result.documents[0];\n      // If we have no error let's return the collection\n      if(err == null && document.ok == 1) {\n        try {\n          var collection = new Collection(self, collectionName, self.pkFactory, options);\n        } catch(err) {\n          return callback(err, null);\n        }\n        return callback(null, collection);\n      } else {\n        err != null ? callback(err, null) : callback(self.wrap(document), null);\n      }\n    });\n  });\n};\n\n/**\n * Execute a command hash against MongoDB. This lets you acess any commands not available through the api on the server.\n *\n * @param {Object} selector the command hash to send to the server, ex: {ping:1}.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.command = function(selector, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  // Set up the options\n  var cursor = new Cursor(this\n    , new Collection(this, DbCommand.SYSTEM_COMMAND_COLLECTION), selector, {}, 0, -1, null, null, null, null, QueryCommand.OPTS_NO_CURSOR_TIMEOUT\n    , null, null, null, null, null, null, null, null, null, null, null, null, null, options['dbName']);\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : false;\n\n  // Ensure only commands who support read Prefrences are exeuted otherwise override and use Primary\n  if(readPreference != false) {\n    if(selector['group'] || selector['aggregate'] || selector['collStats'] || selector['dbStats']\n      || selector['count'] || selector['distinct'] || selector['geoNear'] || selector['geoSearch'] || selector['geoWalk']\n      || (selector['mapreduce'] && selector.out == 'inline')) {\n      // Set the read preference\n      cursor.setReadPreference(readPreference);\n    } else {\n      cursor.setReadPreference(ReadPreference.PRIMARY);\n    }\n  }\n\n  // Return the next object\n  cursor.nextObject(callback);\n};\n\n/**\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @param {String} collectionName the name of the collection we wish to drop.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.dropCollection = function(collectionName, callback) {\n  var self = this;\n\n  // Drop the collection\n  this._executeQueryCommand(DbCommand.createDropCollectionCommand(this, collectionName), function(err, result) {\n    if(err == null && result.documents[0].ok == 1) {\n      if(callback != null) return callback(null, true);\n    } else {\n      if(callback != null) err != null ? callback(err, null) : callback(self.wrap(result.documents[0]), null);\n    }\n  });\n};\n\n/**\n * Rename a collection.\n *\n * @param {String} fromCollection the name of the current collection we wish to rename.\n * @param {String} toCollection the new name of the collection.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.renameCollection = function(fromCollection, toCollection, callback) {\n  var self = this;\n\n  // Execute the command, return the new renamed collection if successful\n  this._executeQueryCommand(DbCommand.createRenameCollectionCommand(this, fromCollection, toCollection), function(err, result) {\n    if(err == null && result.documents[0].ok == 1) {\n      if(callback != null) return callback(null, new Collection(self, toCollection, self.pkFactory));\n    } else {\n      if(callback != null) err != null ? callback(err, null) : callback(self.wrap(result.documents[0]), null);\n    }\n  });\n};\n\n/**\n * Return last error message for the given connection, note options can be combined.\n *\n * Options\n *  - **fsync** {Boolean, default:false}, option forces the database to fsync all files before returning.\n *  - **j** {Boolean, default:false}, awaits the journal commit before returning, > MongoDB 2.0.\n *  - **w** {Number}, until a write operation has been replicated to N servers.\n *  - **wtimeout** {Number}, number of miliseconds to wait before timing out.\n *\n * Connection Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Object} [connectionOptions] returns option results.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.lastError = function(options, connectionOptions, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  connectionOptions = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createGetLastErrorCommand(options, this), connectionOptions, function(err, error) {\n    callback(err, error && error.documents);\n  });\n};\n\n/**\n * Legacy method calls.\n *\n * @ignore\n * @api private\n */\nDb.prototype.error = Db.prototype.lastError;\nDb.prototype.lastStatus = Db.prototype.lastError;\n\n/**\n * Return all errors up to the last time db reset_error_history was called.\n *\n * Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.previousErrors = function(options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createGetPreviousErrorsCommand(this), options, function(err, error) {\n    callback(err, error.documents);\n  });\n};\n\n/**\n * Runs a command on the database.\n * @ignore\n * @api private\n */\nDb.prototype.executeDbCommand = function(command_hash, options, callback) {\n  if(callback == null) { callback = options; options = {}; }\n  this._executeQueryCommand(DbCommand.createDbSlaveOkCommand(this, command_hash, options), options, callback);\n};\n\n/**\n * Runs a command on the database as admin.\n * @ignore\n * @api private\n */\nDb.prototype.executeDbAdminCommand = function(command_hash, options, callback) {\n  if(callback == null) { callback = options; options = {}; }\n  this._executeQueryCommand(DbCommand.createAdminDbCommand(this, command_hash), options, callback);\n};\n\n/**\n * Resets the error history of the mongo instance.\n *\n * Options\n *  - **connection** {Connection}, fire the getLastError down a specific connection.\n *\n * @param {Object} [options] returns option results.\n * @param {Function} callback returns the results.\n * @return {null}\n * @api public\n */\nDb.prototype.resetErrorHistory = function(options, callback) {\n  // Unpack calls\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createResetErrorHistoryCommand(this), options, function(err, error) {\n    callback(err, error.documents);\n  });\n};\n\n/**\n * Creates an index on the collection.\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n *\n * @param {String} collectionName name of the collection to create the index on.\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback for results.\n * @return {null}\n * @api public\n */\nDb.prototype.createIndex = function(collectionName, fieldOrSpec, options, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n  options = typeof callback === 'function' ? options : callback;\n  options = options == null ? {} : options;\n\n  // Collect errorOptions\n  var errorOptions = options.safe != null ? options.safe : null;\n  errorOptions = errorOptions == null && self.safe != null ? self.safe : errorOptions;\n\n  // If we have a write concern set and no callback throw error\n  if(errorOptions != null && errorOptions != false && (typeof callback !== 'function' && typeof options !== 'function')) throw new Error(\"safe cannot be used without a callback\");\n\n  // Create command\n  var command = DbCommand.createCreateIndexCommand(this, collectionName, fieldOrSpec, options);\n  // Default command options\n  var commandOptions = {};\n\n  // If we have error conditions set handle them\n  if(errorOptions && errorOptions != false) {\n    // Insert options\n    commandOptions['read'] = false;\n    // If we have safe set set async to false\n    if(errorOptions == null) commandOptions['async'] = true;\n\n    // Set safe option\n    commandOptions['safe'] = errorOptions;\n    // If we have an error option\n    if(typeof errorOptions == 'object') {\n      var keys = Object.keys(errorOptions);\n      for(var i = 0; i < keys.length; i++) {\n        commandOptions[keys[i]] = errorOptions[keys[i]];\n      }\n    }\n\n    // Execute insert command\n    this._executeInsertCommand(command, commandOptions, function(err, result) {\n      if(err != null) return callback(err, null);\n\n      result = result && result.documents;\n      if (result[0].err) {\n        callback(self.wrap(result[0]));\n      } else {\n        callback(null, command.documents[0].name);\n      }\n    });\n  } else {\n    // Execute insert command\n    var result = this._executeInsertCommand(command, commandOptions);\n    // If no callback just return\n    if(!callback) return;\n    // If error return error\n    if(result instanceof Error) {\n      return callback(result);\n    }\n    // Otherwise just return\n    return callback(null, null);\n  }\n};\n\n/**\n * Ensures that an index exists, if it does not it creates it\n *\n * Options\n *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a\n *  - **unique** {Boolean, default:false}, creates an unique index.\n *  - **sparse** {Boolean, default:false}, creates a sparse index.\n *  - **background** {Boolean, default:false}, creates the index in the background, yielding whenever possible.\n *  - **dropDups** {Boolean, default:false}, a unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n *  - **min** {Number}, for geospatial indexes set the lower bound for the co-ordinates.\n *  - **max** {Number}, for geospatial indexes set the high bound for the co-ordinates.\n *  - **v** {Number}, specify the format version of the indexes.\n *  - **expireAfterSeconds** {Number}, allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n *  - **name** {String}, override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n *\n * @param {String} collectionName name of the collection to create the index on.\n * @param {Object} fieldOrSpec fieldOrSpec that defines the index.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback for results.\n * @return {null}\n * @api public\n */\nDb.prototype.ensureIndex = function(collectionName, fieldOrSpec, options, callback) {\n  var self = this;\n\n  if (typeof callback === 'undefined' && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (options == null) {\n    options = {};\n  }\n\n  // Collect errorOptions\n  var errorOptions = options.safe != null ? options.safe : null;\n  errorOptions = errorOptions == null && self.safe != null ? self.safe : errorOptions;\n\n  // If we have a write concern set and no callback throw error\n  if(errorOptions != null && errorOptions != false && (typeof callback !== 'function' && typeof options !== 'function')) throw new Error(\"safe cannot be used without a callback\");\n\n  // Create command\n  var command = DbCommand.createCreateIndexCommand(this, collectionName, fieldOrSpec, options);\n  var index_name = command.documents[0].name;\n\n  // Default command options\n  var commandOptions = {};\n  // Check if the index allready exists\n  this.indexInformation(collectionName, function(err, collectionInfo) {\n    if(err != null) return callback(err, null);\n\n    if(!collectionInfo[index_name])  {\n      // If we have error conditions set handle them\n      if(errorOptions && errorOptions != false) {\n        // Insert options\n        commandOptions['read'] = false;\n        // If we have safe set set async to false\n        if(errorOptions == null) commandOptions['async'] = true;\n\n        // Set safe option\n        commandOptions['safe'] = errorOptions;\n        // If we have an error option\n        if(typeof errorOptions == 'object') {\n          var keys = Object.keys(errorOptions);\n          for(var i = 0; i < keys.length; i++) {\n            commandOptions[keys[i]] = errorOptions[keys[i]];\n          }\n        }\n\n        self._executeInsertCommand(command, commandOptions, function(err, result) {\n          // Only callback if we have one specified\n          if(typeof callback === 'function') {\n            if(err != null) return callback(err, null);\n\n            result = result && result.documents;\n            if (result[0].err) {\n              callback(self.wrap(result[0]));\n            } else {\n              callback(null, command.documents[0].name);\n            }\n          }\n        });\n      } else {\n        // Execute insert command\n        var result = self._executeInsertCommand(command, commandOptions);\n        // If no callback just return\n        if(!callback) return;\n        // If error return error\n        if(result instanceof Error) {\n          return callback(result);\n        }\n        // Otherwise just return\n        return callback(null, index_name);\n      }\n    } else {\n      if(typeof callback === 'function') return callback(null, index_name);\n    }\n  });\n};\n\n/**\n * Returns the information available on allocated cursors.\n *\n * Options\n *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n *\n * @param {Object} [options] additional options during update.\n * @param {Function} callback for results.\n * @return {null}\n * @api public\n */\nDb.prototype.cursorInfo = function(options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  options = args.length ? args.shift() : {};\n\n  this._executeQueryCommand(DbCommand.createDbSlaveOkCommand(this, {'cursorInfo':1}), options, function(err, result) {\n    callback(err, result.documents[0]);\n  });\n};\n\n/**\n * Drop an index on a collection.\n *\n * @param {String} collectionName the name of the collection where the command will drop an index.\n * @param {String} indexName name of the index to drop.\n * @param {Function} callback for results.\n * @return {null}\n * @api public\n */\nDb.prototype.dropIndex = function(collectionName, indexName, callback) {\n  this._executeQueryCommand(DbCommand.createDropIndexCommand(this, collectionName, indexName), callback);\n};\n\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n *\n * @param {String} collectionName the name of the collection.\n * @param {Function} callback returns the results.\n * @api public\n**/\nDb.prototype.reIndex = function(collectionName, callback) {\n  this._executeQueryCommand(DbCommand.createReIndexCommand(this, collectionName), function(err, result) {\n    if(err != null) {\n      callback(err, false);\n    } else if(result.documents[0].errmsg == null) {\n      callback(null, true);\n    } else {\n      callback(new Error(result.documents[0].errmsg), false);\n    }\n  });\n};\n\n/**\n * Retrieves this collections index info.\n *\n * Options\n *  - **full** {Boolean, default:false}, returns the full raw index information.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {String} collectionName the name of the collection.\n * @param {Object} [options] additional options during update.\n * @param {Function} callback returns the index information.\n * @return {null}\n * @api public\n */\nDb.prototype.indexInformation = function(collectionName, options, callback) {\n  if(typeof callback === 'undefined') {\n    if(typeof options === 'undefined') {\n      callback = collectionName;\n      collectionName = null;\n    } else {\n      callback = options;\n    }\n    options = {};\n  }\n\n  // If we specified full information\n  var full = options['full'] == null ? false : options['full'];\n  // Build selector for the indexes\n  var selector = collectionName != null ? {ns: (this.databaseName + \".\" + collectionName)} : {};\n\n  // Set read preference if we set one\n  var readPreference = options['readPreference'] ? options['readPreference'] : ReadPreference.PRIMARY;\n\n  // Iterate through all the fields of the index\n  this.collection(DbCommand.SYSTEM_INDEX_COLLECTION, function(err, collection) {\n    // Perform the find for the collection\n    collection.find(selector).setReadPreference(readPreference).toArray(function(err, indexes) {\n      if(err != null) return callback(err, null);\n      // Contains all the information\n      var info = {};\n\n      // if full defined just return all the indexes directly\n      if(full) return callback(null, indexes);\n\n      // Process all the indexes\n      for(var i = 0; i < indexes.length; i++) {\n        var index = indexes[i];\n        // Let's unpack the object\n        info[index.name] = [];\n        for(var name in index.key) {\n          info[index.name].push([name, index.key[name]]);\n        }\n      }\n\n      // Return all the indexes\n      callback(null, info);\n    });\n  });\n};\n\n/**\n * Drop a database.\n *\n * @param {Function} callback returns the index information.\n * @return {null}\n * @api public\n */\nDb.prototype.dropDatabase = function(callback) {\n  var self = this;\n\n  this._executeQueryCommand(DbCommand.createDropDatabaseCommand(this), function(err, result) {\n    if (err == null && result.documents[0].ok == 1) {\n      callback(null, true);\n    } else {\n      if (err) {\n        callback(err, false);\n      } else {\n        callback(self.wrap(result.documents[0]), false);\n      }\n    }\n  });\n};\n\n/**\n * Get all the db statistics.\n *\n * Options\n *  - **scale** {Number}, divide the returned sizes by scale value.\n *  - **readPreference** {String}, the preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n *\n * @param {Objects} [options] options for the stats command\n * @param {Function} callback returns statistical information for the db.\n * @return {null}\n * @api public\n */\nDb.prototype.stats = function stats(options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = args.pop();\n  // Fetch all commands\n  options = args.length ? args.shift() : {};\n\n  // Build command object\n  var commandObject = {\n    dbStats:this.collectionName,\n  }\n\n  // Check if we have the scale value\n  if(options['scale'] != null) commandObject['scale'] = options['scale'];\n\n  // Execute the command\n  this.command(commandObject, options, callback);\n}\n\n/**\n * Register a handler\n * @ignore\n * @api private\n */\nDb.prototype._registerHandler = function(db_command, raw, connection, exhaust, callback) {\n  // If we have an array of commands, chain them\n  var chained = Array.isArray(db_command);\n\n  // Check if we have exhausted\n  if(typeof exhaust == 'function') {\n    callback = exhaust;\n    exhaust = false;\n  }\n\n  // If they are chained we need to add a special handler situation\n  if(chained) {\n    // List off chained id's\n    var chainedIds = [];\n    // Add all id's\n    for(var i = 0; i < db_command.length; i++) chainedIds.push(db_command[i].getRequestId().toString());\n    // Register all the commands together\n    for(var i = 0; i < db_command.length; i++) {\n      var command = db_command[i];\n      // Add the callback to the store\n      this._callBackStore.once(command.getRequestId(), callback);\n      // Add the information about the reply\n      this._callBackStore._notReplied[command.getRequestId().toString()] = {start: new Date().getTime(), 'raw': raw, chained:chainedIds, connection:connection, exhaust:false};\n    }\n  } else {\n    // Add the callback to the list of handlers\n    this._callBackStore.once(db_command.getRequestId(), callback);\n    // Add the information about the reply\n    this._callBackStore._notReplied[db_command.getRequestId().toString()] = {start: new Date().getTime(), 'raw': raw, connection:connection, exhaust:exhaust};\n  }\n}\n\n/**\n * Re-Register a handler, on the cursor id f.ex\n * @ignore\n * @api private\n */\nDb.prototype._reRegisterHandler = function(newId, object, callback) {\n  // Add the callback to the list of handlers\n  this._callBackStore.once(newId, object.callback.listener);\n  // Add the information about the reply\n  this._callBackStore._notReplied[newId] = object.info;\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._callHandler = function(id, document, err) {\n  // If there is a callback peform it\n  if(this._callBackStore.listeners(id).length >= 1) {\n    // Get info object\n    var info = this._callBackStore._notReplied[id];\n    // Delete the current object\n    delete this._callBackStore._notReplied[id];\n    // Emit to the callback of the object\n    this._callBackStore.emit(id, err, document, info.connection);\n  }\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._hasHandler = function(id) {\n  // If there is a callback peform it\n  return this._callBackStore.listeners(id).length >= 1;\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._removeHandler = function(id) {\n  // Remove the information\n  if(this._callBackStore._notReplied[id] != null) delete this._callBackStore._notReplied[id];\n  // Remove the callback if it's registered\n  this._callBackStore.removeAllListeners(id);\n  // Force cleanup _events, node.js seems to set it as a null value\n  if(this._callBackStore._events != null) delete this._callBackStore._events[id];\n}\n\n/**\n *\n * @ignore\n * @api private\n */\nDb.prototype._findHandler = function(id) {\n  var info = this._callBackStore._notReplied[id];\n  // Return the callback\n  return {info:info, callback:(this._callBackStore.listeners(id).length >= 1) ? this._callBackStore.listeners(id)[0] : null}\n}\n\n/**\n * @ignore\n */\nvar __executeQueryCommand = function(self, db_command, options, callback) {\n  // Options unpacking\n  var read = options['read'] != null ? options['read'] : false;\n  var raw = options['raw'] != null ? options['raw'] : self.raw;\n  var onAll = options['onAll'] != null ? options['onAll'] : false;\n  var specifiedConnection = options['connection'] != null ? options['connection'] : null;\n\n  // Correct read preference to default primary if set to false, null or primary\n  if(!(typeof read == 'object') && read._type == 'ReadPreference') {\n    read = (read == null || read == 'primary' || read == false) ? ReadPreference.PRIMARY : read;\n    if(!ReadPreference.isValid(read)) return callback(new Error(\"Illegal readPreference mode specified, \" + read));\n  } else if(typeof read == 'object' && read._type == 'ReadPreference') {\n    if(!read.isValid()) return callback(new Error(\"Illegal readPreference mode specified, \" + read.mode));\n  }\n\n  // If we have a read preference set and we are a mongos pass the read preference on to the mongos instance,\n  if(self.serverConfig.isMongos() && read != null && read != false) {\n    db_command.setMongosReadPreference(read);\n  }\n\n  // If we got a callback object\n  if(typeof callback === 'function' && !onAll) {\n    // Override connection if we passed in a specific connection\n    var connection = specifiedConnection != null ? specifiedConnection : null;\n    // Fetch either a reader or writer dependent on the specified read option if no connection\n    // was passed in\n    if(connection == null) {\n      connection = read == null || read == 'primary' || read == false ? self.serverConfig.checkoutWriter(true) : self.serverConfig.checkoutReader(read);\n    }\n\n    // Ensure we have a valid connection\n    if(connection == null) {\n      return callback(new Error(\"no open connections\"));\n    } else if(connection instanceof Error || connection['message'] != null) {\n      return callback(connection);\n    }\n\n    // Perform reaping of any dead connection\n    if(self.reaperEnabled) reaper(self, self.reaperInterval, self.reaperTimeout);\n\n    // Exhaust Option\n    var exhaust = options.exhaust || false;\n\n    // Register the handler in the data structure\n    self._registerHandler(db_command, raw, connection, exhaust, callback);\n\n    // Write the message out and handle any errors if there are any\n    connection.write(db_command, function(err) {\n      if(err != null) {\n        // Call the handler with an error\n        self._callHandler(db_command.getRequestId(), null, err);\n      }\n    });\n  } else if(typeof callback === 'function' && onAll) {\n    var connections = self.serverConfig.allRawConnections();\n    var numberOfEntries = connections.length;\n    // Go through all the connections\n    for(var i = 0; i < connections.length; i++) {\n      // Fetch a connection\n      var connection = connections[i];\n      // Override connection if needed\n      connection = specifiedConnection != null ? specifiedConnection : connection;\n      // Ensure we have a valid connection\n      if(connection == null) {\n        return callback(new Error(\"no open connections\"));\n      } else if(connection instanceof Error) {\n        return callback(connection);\n      }\n\n      // Register the handler in the data structure\n      self._registerHandler(db_command, raw, connection, callback);\n\n      // Write the message out\n      connection.write(db_command, function(err) {\n        // Adjust the number of entries we need to process\n        numberOfEntries = numberOfEntries - 1;\n        // Remove listener\n        if(err != null) {\n          // Clean up listener and return error\n          self._removeHandler(db_command.getRequestId());\n        }\n\n        // No more entries to process callback with the error\n        if(numberOfEntries <= 0) {\n          callback(err);\n        }\n      });\n\n      // Update the db_command request id\n      db_command.updateRequestId();\n    }\n  } else {\n    // Fetch either a reader or writer dependent on the specified read option\n    var connection = read == null || read == 'primary' || read == false ? self.serverConfig.checkoutWriter(true) : self.serverConfig.checkoutReader(read);\n    // Override connection if needed\n    connection = specifiedConnection != null ? specifiedConnection : connection;\n    // Ensure we have a valid connection\n    if(connection == null || connection instanceof Error || connection['message'] != null) return null;\n    // Write the message out\n    connection.write(db_command, function(err) {\n      if(err != null) {\n        // Emit the error\n        self.emit(\"error\", err);\n      }\n    });\n  }\n}\n\n/**\n * @ignore\n */\nvar __retryCommandOnFailure = function(self, retryInMilliseconds, numberOfTimes, command, db_command, options, callback) {\n  if(this._state == 'connected' || this._state == 'disconnected') this._state = 'connecting';\n  // Number of retries done\n  var numberOfRetriesDone = numberOfTimes;\n  // Retry function, execute once\n  var retryFunction = function(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback) {\n    _self.serverConfig.connect(_self, {}, function(err, result, _serverConfig) {\n      // Adjust the number of retries left\n      _numberOfRetriesDone = _numberOfRetriesDone - 1;\n      // Definitively restart\n      if(err != null && _numberOfRetriesDone > 0) {\n        _self._state = 'connecting';\n        // Close the server config\n        _serverConfig.close(function(err) {\n          // Retry the connect\n          setTimeout(function() {\n            retryFunction(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback);\n          }, _retryInMilliseconds);\n        });\n      } else if(err != null && _numberOfRetriesDone <= 0) {\n        _self._state = 'disconnected';\n        // Force close the current connections\n        _serverConfig.close(function(_err) {\n          // Force close the current connections\n          if(typeof _callback == 'function') _callback(err, null);\n        });\n      } else if(err == null && _self.serverConfig.isConnected() == true && Array.isArray(_self.auths) && _self.auths.length > 0) {\n        _self._state = 'connected';\n        // Get number of auths we need to execute\n        var numberOfAuths = _self.auths.length;\n        // Apply all auths\n        for(var i = 0; i < _self.auths.length; i++) {\n          _self.authenticate(_self.auths[i].username, _self.auths[i].password, {'authdb':_self.auths[i].authdb}, function(err, authenticated) {\n            numberOfAuths = numberOfAuths - 1;\n\n            // If we have no more authentications to replay\n            if(numberOfAuths == 0) {\n              if(err != null || !authenticated) {\n                if(typeof _callback == 'function') _callback(err, null);\n                return;\n              } else {\n                // Execute command\n                command(_self, _db_command, _options, _callback);\n\n                // Execute any backed up commands\n                process.nextTick(function() {\n                  // Execute any backed up commands\n                  while(_self.commands.length > 0) {\n                    // Fetch the command\n                    var command = _self.commands.shift();\n                    // Execute based on type\n                    if(command['type'] == 'query') {\n                      __executeQueryCommand(_self, command['db_command'], command['options'], command['callback']);\n                    } else if(command['type'] == 'insert') {\n                      __executeInsertCommand(_self, command['db_command'], command['options'], command['callback']);\n                    }\n                  }\n                });\n              }\n            }\n          });\n        }\n      } else if(err == null && _self.serverConfig.isConnected() == true) {\n        _self._state = 'connected';\n        // Execute command\n        command(_self, _db_command, _options, _callback);\n\n        process.nextTick(function() {\n          // Execute any backed up commands\n          while(_self.commands.length > 0) {\n            // Fetch the command\n            var command = _self.commands.shift();\n            // Execute based on type\n            if(command['type'] == 'query') {\n              __executeQueryCommand(_self, command['db_command'], command['options'], command['callback']);\n            } else if(command['type'] == 'insert') {\n              __executeInsertCommand(_self, command['db_command'], command['options'], command['callback']);\n            }\n          }\n        });\n      } else {\n        _self._state = 'connecting';\n        // Force close the current connections\n        _serverConfig.close(function(err) {\n        // _self.serverConfig.close(function(err) {\n          // Retry the connect\n          setTimeout(function() {\n            retryFunction(_self, _numberOfRetriesDone, _retryInMilliseconds, _numberOfTimes, _command, _db_command, _options, _callback);\n          }, _retryInMilliseconds);\n        });\n      }\n    });\n  };\n\n  // Execute function first time\n  retryFunction(self, numberOfRetriesDone, retryInMilliseconds, numberOfTimes, command, db_command, options, callback);\n}\n\n/**\n * Execute db query command (not safe)\n * @ignore\n * @api private\n */\nDb.prototype._executeQueryCommand = function(db_command, options, callback) {\n  var self = this;\n\n  // Unpack the parameters\n  if (typeof callback === 'undefined') {\n    callback = options;\n    options = {};\n  }\n\n  // fast fail option used for HA, no retry\n  var failFast = options['failFast'] != null ? options['failFast'] : false;\n  // Check if the user force closed the command\n  if(this._applicationClosed) {\n    if(typeof callback == 'function') {\n      return callback(new Error(\"db closed by application\"), null);\n    } else {\n      throw new Error(\"db closed by application\");\n    }\n  }\n\n  // If the pool is not connected, attemp to reconnect to send the message\n  if(this._state == 'connecting' && this.serverConfig.autoReconnect && !failFast) {\n    process.nextTick(function() {\n      self.commands.push({type:'query', 'db_command':db_command, 'options':options, 'callback':callback});\n    })\n  } else if(!this.serverConfig.isConnected() && this.serverConfig.autoReconnect && !failFast) {\n    this._state = 'connecting';\n    // Retry command\n    __retryCommandOnFailure(this, this.retryMiliSeconds, this.numberOfRetries, __executeQueryCommand, db_command, options, callback);\n  } else if(!this.serverConfig.isConnected() && !this.serverConfig.autoReconnect && callback) {\n    // Fire an error to the callback if we are not connected and don't do reconnect\n    callback(new Error(\"no open connections\"), null);\n  } else {\n    // If we have a\n    if(this.serverConfig instanceof ReplSet && this.serverConfig._checkReplicaSet()) {\n      // Execute the command in waiting\n      __executeQueryCommand(self, db_command, options, function(err, result, connection) {\n        if(!err) {\n          process.nextTick(function() {\n            // Force close if we are disconnected\n            if(self._state == 'disconnected') {\n              self.close();\n              return;\n            }\n\n            var replSetGetStatusCommand = DbCommand.createAdminDbCommandSlaveOk(self, {replSetGetStatus:1}, {});\n            // Do a freaking ping\n            __executeQueryCommand(self, replSetGetStatusCommand, {readPreference:ReadPreference.SECONDARY_PREFERRED}, function(_replerr, _replresult) {\n              // Force close if we are disconnected\n              if(self._state == 'disconnected') {\n                self.close(true);\n                return;\n              }\n\n              // Handle the HA\n              if(_replerr == null) {\n                self.serverConfig._validateReplicaset(_replresult, self.auths);\n              }\n            })\n          })\n        }\n        // Call the original method\n        callback(err, result, connection)\n      })\n    } else {\n      __executeQueryCommand(self, db_command, options, callback)\n    }\n  }\n};\n\n/**\n * @ignore\n */\nvar __executeInsertCommand = function(self, db_command, options, callback) {\n  // Always checkout a writer for this kind of operations\n  var connection = self.serverConfig.checkoutWriter();\n  // Get safe mode\n  var safe = options['safe'] != null ? options['safe'] : false;\n  var raw = options['raw'] != null ? options['raw'] : self.raw;\n  var specifiedConnection = options['connection'] != null ? options['connection'] : null;\n  // Override connection if needed\n  connection = specifiedConnection != null ? specifiedConnection : connection;\n\n  // Ensure we have a valid connection\n  if(typeof callback === 'function') {\n    // Ensure we have a valid connection\n    if(connection == null) {\n      return callback(new Error(\"no open connections\"));\n    } else if(connection instanceof Error) {\n      return callback(connection);\n    }\n\n    // We are expecting a check right after the actual operation\n    if(safe != null && safe != false) {\n      // db command is now an array of commands (original command + lastError)\n      db_command = [db_command, DbCommand.createGetLastErrorCommand(safe, self)];\n\n      // Register the handler in the data structure\n      self._registerHandler(db_command[1], raw, connection, callback);\n    }\n  }\n\n  // If we have no callback and there is no connection\n  if(connection == null) return null;\n  if(connection instanceof Error && typeof callback == 'function') return callback(connection, null);\n  if(connection instanceof Error) return null;\n  if(connection == null && typeof callback == 'function') return callback(new Error(\"no primary server found\"), null);\n\n  // Write the message out\n  connection.write(db_command, function(err) {\n    // Return the callback if it's not a safe operation and the callback is defined\n    if(typeof callback === 'function' && (safe == null || safe == false)) {\n      // Perform reaping\n      if(self.reaperEnabled) reaper(self, self.reaperInterval, self.reaperTimeout);\n      // Perform the callback\n      callback(err, null);\n    } else if(typeof callback === 'function'){\n      // Call the handler with an error\n      self._callHandler(db_command[1].getRequestId(), null, err);\n    } else {\n      self.emit(\"error\", err);\n    }\n  });\n}\n\n/**\n * Execute an insert Command\n * @ignore\n * @api private\n */\nDb.prototype._executeInsertCommand = function(db_command, options, callback) {\n  var self = this;\n\n  // Unpack the parameters\n  if(callback == null && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  // Ensure options are not null\n  options = options == null ? {} : options;\n\n  // Check if the user force closed the command\n  if(this._applicationClosed) {\n    if(typeof callback == 'function') {\n      return callback(new Error(\"db closed by application\"), null);\n    } else {\n      throw new Error(\"db closed by application\");\n    }\n  }\n\n  // If the pool is not connected, attemp to reconnect to send the message\n  if(self._state == 'connecting' && this.serverConfig.autoReconnect) {\n    process.nextTick(function() {\n      self.commands.push({type:'insert', 'db_command':db_command, 'options':options, 'callback':callback});\n    })\n  } else if(!this.serverConfig.isConnected() && this.serverConfig.autoReconnect) {\n    this._state = 'connecting';\n    // Retry command\n    __retryCommandOnFailure(this, this.retryMiliSeconds, this.numberOfRetries, __executeInsertCommand, db_command, options, callback);\n  } else if(!this.serverConfig.isConnected() && !this.serverConfig.autoReconnect && callback) {\n    // Fire an error to the callback if we are not connected and don't do reconnect\n    if(callback) callback(new Error(\"no open connections\"), null);\n  } else {\n    // If we have a\n    if(this.serverConfig instanceof ReplSet && this.serverConfig._checkReplicaSet()) {\n      // Execute insert command\n      __executeInsertCommand(self, db_command, options, callback)\n\n      var replSetGetStatusCommand = DbCommand.createAdminDbCommandSlaveOk(self, {replSetGetStatus:1}, {});\n      // Do a freaking ping\n      __executeQueryCommand(self, replSetGetStatusCommand, {readPreference:ReadPreference.SECONDARY_PREFERRED}, function(_replerr, _replresult) {\n        // Force close if we are disconnected\n        if(self._state == 'disconnected') {\n          self.close(true);\n          return;\n        }\n\n        // Handle the HA\n        if(_replerr == null) {\n          self.serverConfig._validateReplicaset(_replresult, self.auths);\n        }\n      })\n    } else {\n      __executeInsertCommand(self, db_command, options, callback)\n    }\n  }\n}\n\n/**\n * Update command is the same\n * @ignore\n * @api private\n */\nDb.prototype._executeUpdateCommand = Db.prototype._executeInsertCommand;\n/**\n * Remove command is the same\n * @ignore\n * @api private\n */\nDb.prototype._executeRemoveCommand = Db.prototype._executeInsertCommand;\n\n/**\n * Wrap a Mongo error document into an Error instance\n * @ignore\n * @api private\n */\nDb.prototype.wrap = function(error) {\n  var msg = error.err || error.errmsg || error;\n  var e = new Error(msg);\n  e.name = 'MongoError';\n\n  // Get all object keys\n  var keys = Object.keys(error);\n  // Populate error object with properties\n  for(var i = 0; i < keys.length; i++) {\n    e[keys[i]] = error[keys[i]];\n  }\n\n  return e;\n}\n\n/**\n * Default URL\n *\n * @classconstant DEFAULT_URL\n **/\nDb.DEFAULT_URL = 'mongodb://localhost:27017/default';\n\n/**\n * Connect to MongoDB using a url as documented at\n *\n *  www.mongodb.org/display/DOCS/Connections\n *\n * Options\n *  - **uri_decode_auth** {Boolean, default:false} uri decode the user name and password for authentication\n *\n * @param {String} url connection url for MongoDB.\n * @param {Object} [options] optional options for insert command\n * @param {Function} callback callback returns the initialized db.\n * @return {null}\n * @api public\n */\nDb.connect = function(url, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;\n  options = args.length ? args.shift() : null;\n  options = options || {};\n  var serverOptions = options.server || {};\n  var replSetServersOptions = options.replSet || options.replSetServers || {};\n  var dbOptions = options.db || {};\n\n  // Ensure empty socket option field\n  serverOptions.socketOptions = serverOptions.socketOptions || {};\n  replSetServersOptions.socketOptions = serverOptions.socketOptions || {};\n\n  // Match the url format\n  var urlRE = new RegExp('^mongo(?:db)?://(?:|([^@/]*)@)([^@/]*)(?:|/([^?]*)(?:|\\\\?([^?]*)))$');\n  var match = (url || Db.DEFAULT_URL).match(urlRE);\n  if (!match)\n    throw Error(\"URL must be in the format mongodb://user:pass@host:port/dbname\");\n\n  var authPart = match[1] || '';\n  var auth = authPart.split(':', 2);\n  if(options['uri_decode_auth']){\n    auth[0] = decodeURIComponent(auth[0]);\n    if(auth[1]){\n      auth[1] = decodeURIComponent(auth[1]);\n    }\n  }\n\n  var hostPart = match[2];\n  var dbname = match[3] || 'default';\n  var urlOptions = (match[4] || '').split(/[&;]/);\n\n  // Ugh, we have to figure out which options go to which constructor manually.\n  urlOptions.forEach(function(opt) {\n    if(!opt) return;\n    var splitOpt = opt.split('='), name = splitOpt[0], value = splitOpt[1];\n\n    // Options implementations\n    switch(name) {\n      case 'slaveOk':\n      case 'slave_ok':\n        serverOptions.slave_ok = (value == 'true');\n        break;\n      case 'poolSize':\n        serverOptions.poolSize = Number(value);\n        break;\n      case 'autoReconnect':\n      case 'auto_reconnect':\n        serverOptions.auto_reconnect = (value == 'true');\n        break;\n      case 'ssl':\n        serverOptions.ssl = (value == 'true');\n        break;\n      case 'replicaSet':\n      case 'rs_name':\n        replSetServersOptions.rs_name = value;\n        break;\n      case 'reconnectWait':\n        replSetServersOptions.reconnectWait = Number(value);\n        break;\n      case 'retries':\n        replSetServersOptions.retries = Number(value);\n        break;\n      case 'readSecondary':\n      case 'read_secondary':\n        replSetServersOptions.retries = Number(value);\n        break;\n      case 'safe':\n        dbOptions.safe = (value == 'true');\n        break;\n      case 'nativeParser':\n      case 'native_parser':\n        dbOptions.native_parser = (value == 'true');\n        break;\n      case 'safe':\n        dbOptions.safe = (value == 'true');\n        break;\n      case 'connectTimeoutMS':\n        serverOptions.socketOptions.connectTimeoutMS = Number(value);\n        replSetServersOptions.socketOptions.connectTimeoutMS = Number(value);\n        break;\n      case 'socketTimeoutMS':\n        serverOptions.socketOptions.socketTimeoutMS = Number(value);\n        replSetServersOptions.socketOptions.socketTimeoutMS = Number(value);\n        break;\n      default:\n        break;\n    }\n  });\n\n  var servers = hostPart.split(',').map(function(h) {\n    var hostPort = h.split(':', 2);\n    return new Server(hostPort[0] || 'localhost', hostPort[1] != null ? parseInt(hostPort[1]) : 27017, serverOptions);\n  });\n\n  var server;\n  if (servers.length == 1) {\n    server = servers[0];\n  } else {\n    server = new ReplSet(servers, replSetServersOptions);\n  }\n\n  var db = new Db(dbname, server, dbOptions);\n  if(options.noOpen)\n    return db;\n\n  // If callback is null throw an exception\n  if(callback == null) throw new Error(\"no callback function provided\");\n\n  db.open(function(err, db){\n    if(err == null && authPart){\n      db.authenticate(auth[0], auth[1], function(err, success){\n        if(success){\n          callback(null, db);\n        } else {\n          callback(err ? err : new Error('Could not authenticate user ' + auth[0]), db);\n        }\n      });\n    } else {\n      callback(err, db);\n    }\n  });\n}\n\n/**\n * State of the db connection\n * @ignore\n */\nObject.defineProperty(Db.prototype, \"state\", { enumerable: true\n  , get: function () {\n      return this.serverConfig._serverState;\n    }\n});\n\n/**\n * Legacy support\n *\n * @ignore\n * @api private\n */\nexports.connect = Db.connect;\nexports.Db = Db;\n\n/**\n * Remove all listeners to the db instance.\n * @ignore\n * @api private\n */\nDb.prototype.removeAllEventListeners = function() {\n  this.removeAllListeners(\"close\");\n  this.removeAllListeners(\"error\");\n  this.removeAllListeners(\"timeout\");\n  this.removeAllListeners(\"parseError\");\n  this.removeAllListeners(\"poolReady\");\n  this.removeAllListeners(\"message\");\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":79697}]],"length":79697}
